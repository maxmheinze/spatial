---
title: '**Spatial Economics -- Assignment 2**'
author: 
  - "Max Heinze (h11742049@s.wu.ac.at)"
  - "Jaime Miravet (h12235992@s.wu.ac.at)"
  - "Jan Trimmel (h11809096@s.wu.ac.at)"
date: "April 12, 2024"
output: 
  pdf_document:
    toc: true
    citation_package: biblatex
    includes:
      in_header: !expr file.path(rprojroot::find_rstudio_root_file(), "helper", "wrap_code.tex")
bibliography: references.bib
biblio-style: apa
header-includes: 
  - \usepackage{tcolorbox}
  - \usepackage{graphicx}
  - \usepackage{booktabs}
  - \usepackage[default]{lato}
papersize: a4
geometry: margin = 2cm
urlcolor: DarkOrchid!65!black
citecolor: DarkOrchid!65!black
---

```{r, setup, include = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 80), tidy = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
library(showtext)
font_add_google("Lato", "Lato")
showtext_auto()
```

\vspace{2em}

\begin{tcolorbox}
\centering \itshape The executable code that was used in compiling the assignment is available on GitHub at \url{https://github.com/maxmheinze/spatial}.
\end{tcolorbox}

\newpage

# Task A

Text

\newpage

# Task B

## Nice Maps

We create four maps:

```{r, out.width = "70%", fig.align = "center", echo = FALSE, dev = "png", dpi = 300}

# Header ------------------------------------------------------------------

pacman::p_load(
  tidyverse,
  tmap,
  haven,
  foreign,
  magrittr,
  sf,
  stargazer,
  conleyreg,
  estimatr,
  fixest
)


# Prepare Dataframe -------------------------------------------------------

litr <- read_dta("./assignment2/data/literacy_Arg-Bra-Par.dta", encoding = "ISO-8859-1")

shp0 <- read_sf("./assignment2/data/task_b_shapefile_0.shp")
shp1 <- read_sf("./assignment2/data/task_b_shapefile_1.shp")
shp2 <- read_sf("./assignment2/data/task_b_shapefile_2.shp")

spli <- shp2 %>%
  left_join(litr, by = c("NAME_2" = "muni"))


# Literacy Map ------------------------------------------------------------

tm_shape(spli) + 
  tm_fill("literacy", palette = "Reds", style = "equal", n = 10) + 
  tm_borders(col = "#BBBBBB") + 
  tm_shape(shp1) + 
  tm_borders(col = "#444444") + 
  tm_text("NAME_1", size = 0.75, col = "black", bg.color = "#FFFFFF") +
  tm_shape(shp0) + 
  tm_borders(col = "#000000") +
  tm_compass(position = c("right", "top"), size = 2) +
  tm_scale_bar(position = c("right", "bottom"), text.size = 0.5) +
  tm_layout(title = "Literacy Rate by Municipality", 
            title.bg.color = "white", 
            legend.position = c("left", "bottom"),
            legend.bg.color = "white", 
            frame = FALSE,
            fontfamily = "Lato")


# Population Density Map --------------------------------------------------

tm_shape(spli) + 
  tm_fill("popd", palette = "Blues", style = "quantile", n = 10) + 
  tm_borders(col = "#BBBBBB") + 
  tm_shape(shp1) + 
  tm_borders(col = "#444444") + 
  tm_text("NAME_1", size = 0.75, col = "black", bg.color = "#FFFFFF") +
  tm_shape(shp0) + 
  tm_borders(col = "#000000") +
  tm_compass(position = c("right", "top"), size = 2) +
  tm_scale_bar(position = c("right", "bottom"), text.size = 0.5) +
  tm_layout(title = "Population Density by Municipality", 
            title.bg.color = "white", 
            legend.position = c("left", "bottom"),
            legend.bg.color = "white", 
            frame = FALSE,
            fontfamily = "Lato")


# Jesuit Distance Map -----------------------------------------------------

tm_shape(spli) + 
  tm_fill("distmiss", palette = "-Purples", style = "equal", n = 10) + 
  tm_borders(col = "#BBBBBB") + 
  tm_shape(shp1) + 
  tm_borders(col = "#444444") + 
  tm_text("NAME_1", size = 0.75, col = "black", bg.color = "#FFFFFF") +
  tm_shape(shp0) + 
  tm_borders(col = "#000000") +
  tm_compass(position = c("right", "top"), size = 2) +
  tm_scale_bar(position = c("right", "bottom"), text.size = 0.5) +
  tm_layout(title = "Distance from Jesuit Missions by Municipality", 
            title.bg.color = "white", 
            legend.position = c("left", "bottom"),
            legend.bg.color = "white", 
            frame = FALSE,
            fontfamily = "Lato")

# Franciscan Distance Map -------------------------------------------------

tm_shape(spli) + 
  tm_fill("distfran", palette = "-Greens", style = "equal", n = 10) + 
  tm_borders(col = "#BBBBBB") + 
  tm_shape(shp1) + 
  tm_borders(col = "#444444") + 
  tm_text("NAME_1", size = 0.75, col = "black", bg.color = "#FFFFFF") +
  tm_shape(shp0) + 
  tm_borders(col = "#000000") +
  tm_compass(position = c("right", "top"), size = 2) +
  tm_scale_bar(position = c("right", "bottom"), text.size = 0.5) +
  tm_layout(title = "Distance from Franciscan Missions by Municipality", 
            title.bg.color = "white", 
            legend.position = c("left", "bottom"),
            legend.bg.color = "white", 
            frame = FALSE,
            fontfamily = "Lato")
```

## Replication of Table 2

Below are code and results of our replication of Table 2 from \textcite{valencia2019}. Since the original author used Stata's robust standard errors, a notorious problem for replication in R, we specifically report Stata-style standard errors in the table below using the `starprep` function from the `estimatr` package. Using these standard errors, we can reproduce both coefficients and standard errors exactly.

```{r}

# Replicate Results -------------------------------------------------------
col1 <- lm(illiteracy ~ distmiss + lati + longi + corr + ita + mis + mis1, data = litr)
col2 <- lm(illiteracy ~ distmiss + lati + longi + area + tempe + alti + preci + rugg + river + coast + corr + ita + mis + mis1, data = litr)

litr_bra <- subset(litr, country == "BRA")
col3 <- lm(illiteracy ~ distmiss + lati + longi + as.factor(mesorregi), data = litr_bra)
col4 <- lm(illiteracy ~ distmiss + lati + longi + area + tempe + alti + preci + rugg + river + coast + as.factor(mesorregi), data = litr_bra)

litr_arg <- subset(litr, country == "Argentina")
col5 <- lm(illiteracy ~ distmiss + lati + longi + corr, data = litr_arg)
col6 <- lm(illiteracy ~ distmiss + lati + longi + area + tempe + alti + preci + rugg + river + coast + corr, data = litr_arg)

litr_pry <- subset(litr, country == "Paraguay")
col7 <- lm(illiteracy ~ distmiss + ita, data = litr_pry)
col8 <- lm(illiteracy ~ distmiss + area + tempe + alti + preci + rugg + river + coast + ita, data = litr_pry)

```

```{r, echo = FALSE, results='asis'}
cat("\\begin{center}")
cat("\\scalebox{.9}{")



stargazer(col1, col2, col3, col4,
          type = "latex", header=FALSE, no.space = TRUE, column.sep.width = "3pt", float = FALSE,
          se = starprep(col1, col2, col3, col4, se_type = "stata"),
          omit.stat = "f")

cat("}")
cat("\\end{center}")
```

```{r, echo = FALSE, results='asis'}
cat("\\begin{center}")
cat("\\scalebox{.9}{")

stargazer(col5, col6, col7, col8,
          type = "latex", header=FALSE, no.space = TRUE, column.sep.width = "3pt", float = FALSE,
          se = starprep(col5, col6, col7, col8, se_type = "stata"),
          omit.stat = "f")

cat("}")
cat("\\end{center}")
```

Next, we try to reproduce the Conley standard errors. We try two different approaches, first using the `conleyreg` package and then using the `fixest` package. \textcite{valencia2019} specifies a cutoff distance of 0.1 degrees. Both packages we use only allow us to specify the cutoff distance in kilometers, so for the sake of simplicity, we use the distance that 0.1 degrees equal at the equator, which is 6 nautical miles, or approximately 11.112 kilometers. We first print the results from the `conleyreg` package and then from the `fixest` package.

```{r}
lit1 <- litr %>%
  drop_na(lati, longi) %>%
  mutate(lat = lati,
         lon = longi)

col1c <- conleyreg(illiteracy ~ distmiss + lati + longi + corr + ita + mis + mis1, data = lit1,
           dist_cutoff = 11.112, lat = "lat", lon = "lon")
col2c <- conleyreg(illiteracy ~ distmiss + lati + longi + area + tempe + alti + preci + rugg + river + coast + corr + ita + mis + mis1, data = lit1,
           dist_cutoff = 11.112, lat = "lat", lon = "lon")

lit1_bra <- subset(lit1, country == "BRA")
col3c <- conleyreg(illiteracy ~ distmiss + lati + longi + as.factor(mesorregi), data = lit1_bra,
           dist_cutoff = 11.112, lat = "lat", lon = "lon")
col4c <- conleyreg(illiteracy ~ distmiss + lati + longi + area + tempe + alti + preci + rugg + river + coast + as.factor(mesorregi), data = lit1_bra,
           dist_cutoff = 11.112, lat = "lat", lon = "lon")

lit1_arg <- subset(lit1, country == "Argentina")
col5c <- conleyreg(illiteracy ~ distmiss + lati + longi + corr, data = lit1_arg,
           dist_cutoff = 11.112, lat = "lat", lon = "lon")
col6c <- conleyreg(illiteracy ~ distmiss + lati + longi + area + tempe + alti + preci + rugg + river + coast + corr, data = lit1_arg,
           dist_cutoff = 11.112, lat = "lat", lon = "lon")

lit1_pry <- subset(lit1, country == "Paraguay")
col7c <- conleyreg(illiteracy ~ distmiss + ita, data =  lit1_pry,
                   dist_cutoff = 11.112, lat = "lat", lon = "lon")
col8c <- conleyreg(illiteracy ~ distmiss + area + tempe + alti + preci + rugg + river + coast + ita, data =  lit1_pry,
                   dist_cutoff = 11.112, lat = "lat", lon = "lon")
```

```{r, echo = FALSE, results='asis'}
cat("\\begin{center}")
cat("\\scalebox{.9}{")

stargazer(col1c, col2c, col3c, col4c, type = "latex", header=FALSE, no.space = TRUE, column.sep.width = "3pt", float = FALSE)

cat("}")
cat("\\end{center}")
```

```{r, echo = FALSE, results='asis'}
cat("\\begin{center}")
cat("\\scalebox{.9}{")

stargazer(col5c, col6c, col7c, col8c, column.labels = c("(5)", "(6)", "(7)", "(8)"), model.numbers = FALSE, type = "latex", header=FALSE, no.space = TRUE, column.sep.width = "3pt", float = FALSE)

cat("}")
cat("\\end{center}")
```

```{r}
col1cf <- feols(illiteracy ~ distmiss + lati + longi + corr + ita + mis + mis1, data = litr, 
                 vcov_conley(lat = "lati", lon = "longi", cutoff = 11.112, distance = "spherical"))
col2cf <- feols(illiteracy ~ distmiss + lati + longi + area + tempe + alti + preci + rugg + river + coast + corr + ita + mis + mis1, data = litr, 
                 vcov_conley(lat = "lati", lon = "longi", cutoff = 11.112, distance = "spherical"))

col3cf <- feols(illiteracy ~ distmiss + lati + longi + as.factor(mesorregi), data = litr_bra, 
                 vcov_conley(lat = "lati", lon = "longi", cutoff = 11.112, distance = "spherical"))
col4cf <- feols(illiteracy ~ distmiss + lati + longi + area + tempe + alti + preci + rugg + river + coast + as.factor(mesorregi), data = litr_bra, 
                 vcov_conley(lat = "lati", lon = "longi", cutoff = 11.112, distance = "spherical"))

col5cf <- feols(illiteracy ~ distmiss + lati + longi + corr, data = litr_arg, 
                 vcov_conley(lat = "lati", lon = "longi", cutoff = 11.112, distance = "spherical"))
col6cf <- feols(illiteracy ~ distmiss + lati + longi + area + tempe + alti + preci + rugg + river + coast + corr, data = litr_arg, 
                 vcov_conley(lat = "lati", lon = "longi", cutoff = 11.112, distance = "spherical"))

col7cf <- feols(illiteracy ~ distmiss + ita, data = litr_pry, 
                 vcov_conley(lat = "lati", lon = "longi", cutoff = 11.112, distance = "spherical"))
col8cf <- feols(illiteracy ~ distmiss + area + tempe + alti + preci + rugg + river + coast + ita, data = litr_pry, 
                 vcov_conley(lat = "lati", lon = "longi", cutoff = 11.112, distance = "spherical"))
```

```{r, echo = FALSE, results='asis'}
cat("\\scalebox{.8}{")
etable(col1cf, col2cf, col3cf, col4cf, col5cf, col6cf, col7cf, col8cf, tex = TRUE)
cat("}")
```

Evidently, we could not reproduce the exact Conley standard errors reported in \textcite{valencia2019}. And the two packages yielded different errors even though we specified the same cutoff (11.112 kilometers) and the same method of distance calculation (spherical). 

## Ways to Use Distance

In his specification, Felipe \textcite{valencia2019} uses the following specification (Eq. 1 in the paper):

$$
Y_{2000,ij} = \alpha + \beta d(M_{ij}) + \gamma GEO_{ij}+\mu_j + \varepsilon_{ij},
$$

where $d(\cdot)$ is described as either being a dummy for the presence of a mission or the plain (i.e., untransformed) distance, although we do not fine examples of the former in any of the printed tables in the paper, so we will just be calling it the distance. The decaying impact of a mission can be plotted against distance as follows:

```{r, echo = FALSE, out.width = "50%", fig.align = "center"}
ggplot() +
  geom_function(col = "#995082", size = 1.5, fun = function(x) x) +
  xlim(0, 1000) +
  labs(x = "x", y = "d(x)") +
  theme_minimal() +
  theme(text = element_text(family = "Lato"))
```

If we view $d(\cdot)$ as _impact_ exerted by a mission, it might be more intuitive to plot the negative of it, so that a higher value corresponds to more impact.

```{r, echo = FALSE, out.width = "50%", fig.align = "center"}
ggplot() +
  geom_function(col = "#995082", size = 1.5, fun = function(x) -x) +
  xlim(0, 1000) +
  labs(x = "x", y = "-d(x)") +
  theme_minimal() +
  theme(text = element_text(family = "Lato"))
```

If we draw a map and plot distance from a mission using this function, we get the same map as above.

```{r, echo = FALSE, out.width = "70%", fig.align = "center", dev = "png", dpi = 300}
tm_shape(spli) + 
  tm_fill("distmiss", palette = "-Purples", style = "equal", n = 10) + 
  tm_borders(col = "#BBBBBB") + 
  tm_shape(shp1) + 
  tm_borders(col = "#444444") + 
  tm_text("NAME_1", size = 0.75, col = "black", bg.color = "#FFFFFF") +
  tm_shape(shp0) + 
  tm_borders(col = "#000000") +
  tm_compass(position = c("right", "top"), size = 2) +
  tm_scale_bar(position = c("right", "bottom"), text.size = 0.5) +
  tm_layout(title = "Distance from Jesuit Missions, Linear", 
            title.bg.color = "white", 
            legend.position = c("left", "bottom"),
            legend.bg.color = "white", 
            frame = FALSE,
            fontfamily = "Lato")
```


Letting $d$ be

$$
d: \mathbb{R} \to \mathbb{R}, \quad x \mapsto x
$$

means that we attribute the same change in impact to moving from 0km from the treatment position to 100km from it, as to moving from 900km distance to 1000km. This is quite an assumption. Alternatively, we could use the **logarithm** of the distance, 

$$
d: \mathbb{R} \to \mathbb{R}, \quad x \mapsto \mathrm{log}(x),
$$

like this:

```{r, echo = FALSE, out.width = "50%", fig.align = "center"}
ggplot() +
  geom_function(col = "#995082", size = 1.5, fun = function(x) -log(x)) +
  xlim(0, 1000) +
  labs(x = "x", y = "-d(x)") +
  theme_minimal() +
  theme(text = element_text(family = "Lato"))
```

This gives the following map.

```{r, echo = FALSE, out.width = "70%", fig.align = "center", dev = "png", dpi = 300}
tm_shape(mutate(spli, distmissx = log(distmiss))) + 
  tm_fill("distmissx", palette = "-Purples", style = "equal", n = 10) + 
  tm_borders(col = "#BBBBBB") + 
  tm_shape(shp1) + 
  tm_borders(col = "#444444") + 
  tm_text("NAME_1", size = 0.75, col = "black", bg.color = "#FFFFFF") +
  tm_shape(shp0) + 
  tm_borders(col = "#000000") +
  tm_compass(position = c("right", "top"), size = 2) +
  tm_scale_bar(position = c("right", "bottom"), text.size = 0.5) +
  tm_layout(title = "Distance from Jesuit Missions, Logarithmic", 
            title.bg.color = "white", 
            legend.position = c("left", "bottom"),
            legend.bg.color = "white", 
            frame = FALSE,
            fontfamily = "Lato")
```

We can see that unlike in the linear case, the differences between distances at a greater length from the locations of treatment are weighted down, whereas distance differences closer to the mission are exaggerated. It could make sense to use such a specification instead of a linear one if we suspect impacts of a mission to be roughly comparable between places that are 400 or 500 kilometers from the closest mission, or if we are concerned that portions of Rio Grande do Sul are included in the analysis that are much farther from where Jesuits went than portions of Argentinian or Paraguayan states that were not included.

Alternatively, we could consider a **negative exponential** specification,

$$
d: \mathbb{R} \to \mathbb{R}, \quad x \mapsto \mathrm{exp}(-\lambda x),
$$

which is plotted below for $\lambda = \tfrac{1}{500}$:

```{r, echo = FALSE, out.width = "50%", fig.align = "center"}
ggplot() +
  geom_function(col = "#995082", size = 1.5, fun = function(x) exp(-x/200)) +
  xlim(0, 1000) +
  labs(x = "x", y = "d(x)") +
  theme_minimal() +
  theme(text = element_text(family = "Lato"))
```

Applying to our data, it looks like this:

```{r, echo = FALSE, out.width = "70%", fig.align = "center", dev = "png", dpi = 300}
tm_shape(mutate(spli, distmissx = exp(-distmiss/200))) + 
  tm_fill("distmissx", palette = "Purples", style = "equal", n = 10) + 
  tm_borders(col = "#BBBBBB") + 
  tm_shape(shp1) + 
  tm_borders(col = "#444444") + 
  tm_text("NAME_1", size = 0.75, col = "black", bg.color = "#FFFFFF") +
  tm_shape(shp0) + 
  tm_borders(col = "#000000") +
  tm_compass(position = c("right", "top"), size = 2) +
  tm_scale_bar(position = c("right", "bottom"), text.size = 0.5) +
  tm_layout(title = "Distance from Jesuit Missions, Negative Exponential", 
            title.bg.color = "white", 
            legend.position = c("left", "bottom"),
            legend.bg.color = "white", 
            frame = FALSE,
            fontfamily = "Lato")
```

By adjusting $\lambda$, we can make the decay more or less “aggressive.” With our present specification, it is “between” the linear and logarithmic cases.

Lastly, we could consider using a **Gaussian** decay function, like this:

$$
d: \mathbb{R} \to \mathbb{R}, \quad x \mapsto \mathrm{exp}\left(-\frac{x^2}{2\sigma^2}\right)
$$
Letting $\sigma=100$ gives the following:

```{r, echo = FALSE, out.width = "50%", fig.align = "center"}
ggplot() +
  geom_function(col = "#995082", size = 1.5, fun = function(x) exp(-(x^2)/(2*100^2))) +
  xlim(0, 1000) +
  labs(x = "x", y = "d(x)") +
  theme_minimal() +
  theme(text = element_text(family = "Lato"))
```

We can see that by using the Gaussian decay function, we can model something that is closer to a “cutoff.” Applying this function to the data gives the following map:

```{r, echo = FALSE, out.width = "70%", fig.align = "center", dev = "png", dpi = 300}
tm_shape(mutate(spli, distmissx = exp(-(distmiss^2)/(2*100^2)))) + 
  tm_fill("distmissx", palette = "Purples", style = "equal", n = 10) + 
  tm_borders(col = "#BBBBBB") + 
  tm_shape(shp1) + 
  tm_borders(col = "#444444") + 
  tm_text("NAME_1", size = 0.75, col = "black", bg.color = "#FFFFFF") +
  tm_shape(shp0) + 
  tm_borders(col = "#000000") +
  tm_compass(position = c("right", "top"), size = 2) +
  tm_scale_bar(position = c("right", "bottom"), text.size = 0.5) +
  tm_layout(title = "Distance from Jesuit Missions, Gaussian", 
            title.bg.color = "white", 
            legend.position = c("left", "bottom"),
            legend.bg.color = "white", 
            frame = FALSE,
            fontfamily = "Lato")
```

We can clearly see that different functions yield vastly different distance measures across municipalities. So it is quite sensible to suspect that estimation results are subject to the choice of distance measure. To check this, we run the regression from column (2) of Table 2 again -- but each time with a different distance measure.

```{r}
litrd <- litr %>%
  mutate(distmiss_log = log(distmiss),
         distmiss_exp = exp(-distmiss/200),
         distmiss_gau = exp(-(distmiss^2)/(2*100^2)))

col2_reg <- lm(illiteracy ~ distmiss + lati + longi + area + tempe + alti + preci + rugg + river + coast + corr + ita + mis + mis1, data = litrd)
col2_log <- lm(illiteracy ~ distmiss_log + lati + longi + area + tempe + alti + preci + rugg + river + coast + corr + ita + mis + mis1, data = litrd)
col2_exp <- lm(illiteracy ~ distmiss_exp + lati + longi + area + tempe + alti + preci + rugg + river + coast + corr + ita + mis + mis1, data = litrd)
col2_gau <- lm(illiteracy ~ distmiss_gau + lati + longi + area + tempe + alti + preci + rugg + river + coast + corr + ita + mis + mis1, data = litrd)
```

```{r, echo = FALSE, results='asis'}
cat("\\begin{center}")
cat("\\scalebox{.8}{")
stargazer(col2_reg, col2_log, col2_exp, col2_gau,
          type = "latex",
          se = starprep(col2_reg, col2_log, col2_exp, col2_gau, se_type = "stata"),
          omit.stat = "f",
          float = FALSE,
          header=FALSE)
cat("}")
cat("\\end{center}")
```

Of course, coefficient magnitudes cannot be directly compared, since we wildly scaled and transformed the distance measure. Even the sign changes do not necessarily need to worry us, since we transformed distance measures in a way that they sometimes shrank and sometimes increased with increasing distance. However, we see that using the different distance measures, effect sizes are no longer statistically different from zero.

## Persistence and Space, or: Where's Waldo?

Because any text about spatial autocorrelation would be incomplete without reciting Waldo\footnote{Here he is.} Tobler's First Law of Geography, here it is in all its beauty: “Everything is related to everything else, but near things are more related than distant things.” Applied to the present context, this has important implications.

First, the presence of a mission in some given municipality is likely autocorrelated with whether adjacent municipalities were subject to missionary activity too. If the first missionaries went to some place in what we today call Misiones, it is likely that subsequent missionaries built on locally specific knowledge of earlier missions and settled near them. Our distance plots, especially the logarithmic one, are a good indication of that autocorrelation, since we can see that all missions were more or less in the same region. 

Second, we can assume literacy rates to be spatially autocorrelated as well. Again, we can see this from the map we originally produced where we plotted literacy rates across the regions analyzed by \textcite{valencia2019}. We can see that high literacy rates concentrate in one region around the Argentinian state of Misiones and the northwestern part of Rio Grande do Sul, and in one region in the eastern part of Rio Grande do Sul. And if we take a glance at the map below, we can also see that these regions are clusters of higher population density.

\textcite{kelly2021} notes that this covert relation leads to standard errors usually being too low since the presence of spatial clusters in two variables means that whatever correlation exists between the variables in one locality is likely to also be present in adjacent localities. He also notes that different types of available standard error corrections lead to widely different results. Conley standard errors, which \textcite{valencia2019} uses as a robustness check, tend to be the most conservative of the corrections. Having standard errors that are too small, of course, does not bias the estimate, but will cause false positive results. 

The same can be thought of if there are potential confounders. If there is a unobserved spatial variable that influences the outcome and that is correlated with the covariates that are included in the model, the coefficient estimates will be biased \parencite{dupont2023}. Assuming the variables considered in the model in \textcite{valencia2019} behave like most other socioeconomic variables in space, we can assume that any spatial effect will be correlated with the model covariates, leading to the possibility of biased coefficients. 

\newpage

# Task C

## The perils of ignoring peer effects

\newpage

# Task D

The image is a screenshot, and those are conventionally stored in PNG format. The photo _contained_ in the screenshot is a photograph, and it is difficult to guess which format it was originally saved in. Let's say it's JPEG. Then, someone inserted the image into the assignment PDF, meaning it is technically not stored as a PNG anymore. What all those ways of storing the image have in common is that they are **raster formats**, as they consist of individual pixels. And even if we print the document containing the image, it gets printed as dots, which are not exactly pixels, but certainly form a raster rather than a vector.

\newpage
